# -*- mode: shell-script -*-
#
# xs-functions: common functions for xs-* scripts
#

# functions defined here will not emit messages (other than those
# emanating from xe invocations) if global variable QUIET is non-zero
QUIET=0

if ! which xe > /dev/null 2>&1; then
    echo "xe is not in your shell's path."
    exit 1
fi

# connection information for pool master
XE_SERVER="${XE_SERVER=127.0.0.1}"
XE_PORT="${XE_PORT=443}"
XE_USERNAME="${XE_USERNAME=root}"
XE_PASSWORD="${XE_PASSWORD=root!!!}"
[ -z "$XE_EXTRA_ARGS" ] && export XE_EXTRA_ARGS="server=$XE_SERVER,port=$XE_PORT,username=$XE_USERNAME,password=$XE_PASSWORD"

########################################################################
# 
# Functions for XenServer object commands
#

# get array of UUIDs from name label; set global variable UUIDS
# $1: object type
# $2: name label (may be empty string)
# $...: parameter name/value pairs (optional)
function get_uuids() {
    [ $# -lt 2 ] && return 2
    UUIDS=()
    local OBJECT="$1" NAME_LABEL="$2"
    shift 2
    local CMD="xe $OBJECT-list"
    [ -n "$NAME_LABEL" ] && CMD="$CMD name-label=\"$NAME_LABEL\""
    local PARAM_NAME PARAM_VALUE
    while [ -n "$1" ]; do
        PARAM_NAME="$1"
        shift
        PARAM_VALUE="$1"
        shift
        CMD="$CMD $PARAM_NAME=\"$PARAM_VALUE\""
    done
    CMD="$CMD --minimal"
    local XE_OUT=$(eval "$CMD")
    if [ -z "$XE_OUT" ]; then
        return 1
    elif [[ "$XE_OUT" =~ , ]]; then
        UUIDS=( ${XE_OUT//,/ } )
        return 3
    else
        UUIDS=( "$XE_OUT" )
        return 0
    fi
}

function get_uuid() {
    [ $# -lt 2 ] && return 2
    UUID=""
    get_uuids "$@"
    case $? in
        0)
            UUID="${UUIDS[0]}"
            return 0
            ;;
        3)
            (( QUIET )) || echo "Multiple ${OBJECT}s found"
            return 1
            ;;
        *)
            return $?
    esac
}

# get SR UUID for local storage on host; set global variable SR_UUID
function get_local_sr_uuid() {
    [ -z "$1" ] && return 2
    SR_UUID=$(xe sr-list params=uuid name-label='Local storage' host="$1" --minimal)
    if [ -z "$SR_UUID" ]; then
        echo "Storage repository \"Local storage\" on host $HOST not found"
        return 1
    else
        return 0
    fi
}

# get value of param name from UUID; set global variable PARAM_VALUE
function get_param() {
    [ $# -ne 3 ] && return 2
    PARAM_VALUE=$(xe "$1"-param-get param-name="$2" uuid="$3")
    RETURN=$?
    if [ "$PARAM_VALUE" == "<not in database>" ]; then
        return 2
    else
        return "$RETURN"
    fi
}

# get array of VIF UUIDs from VM UUID; set global variable VIF_UUIDS
function vm_vif_uuids() {
    [ -z "$1" ] && return 2
    VI_UUIDS=()
    local XE_OUT=$(xe vif-list vm-uuid="$1" --minimal)
    VIF_UUIDS=( ${XE_OUT//,/ } )
    return $?
}

# get array of VBD UUIDs from VM UUID; set global variable VBD_UUIDS
function vm_vbd_uuids() {
    [ -z "$1" ] && return 2
    VBD_UUIDS=()
    local XE_OUT=$(xe vbd-list vm-uuid="$1" --minimal)
    VBD_UUIDS=( ${XE_OUT//,/ } )
    return $?
}

# get network UUID from VIF UUID; set global variable NETWORK_UUID
function vif_network_uuid() {
    [ -z "$1" ] && return 2
    NETWORK_UUID=$(xe vif-param-get param-name=network-uuid uuid="$1")
    return $?
}

# get VDI UUID from VBD UUID; set global variable VDI_UUID
function vbd_vdi_uuid() {
    [ -z "$1" ] && return 2
    VDI_UUID=$(xe vbd-param-get param-name=vdi-uuid uuid="$1")
    return $?
}

# get VIF device from VIF UUID; set global variable VIF_DEVICE
function vif_device() {
    [ -z "$1" ] && return 2
    VIF_DEVICE=$(xe vif-param-get param-name=device uuid="$1")
    return $?
}

# get PIF VLAN from network UUID; set global variable PIF_VLAN
function network_pif_vlan() {
    [ -z "$1" ] && return 2
    PIF_VLAN=$(xe pif-list params=VLAN network-uuid="$1" --minimal)
    return $?
}

# get name label of host running VM or preferred host for VM or host
# housing VM's primary VDI (assumed to be hda for HVM and xvda for
# PV); include type of association (resident, affinity, SR) if a
# second argument is passed
function vm_host() {
    [ -z "$1" ] && return 2
    [ $# -gt 2 ] && return 2
    local VM_UUID="$1"
    if [ -n "$2" ]; then
        local ASSOC=1
    else
        local ASSOC=0
    fi
    VM_HOST=""
    local VM_ASSOC PARAM_VALUE
    # check for residency
    if get_param vm resident-on "$VM_UUID" && \
        get_param host name-label "$PARAM_VALUE"; then
        VM_HOST="$PARAM_VALUE"
        (( ASSOC )) && VM_ASSOC=( "resident" )
    fi
    # check for affinity
    if get_param vm affinity "$VM_UUID" && \
        get_param host name-label "$PARAM_VALUE"; then
        local AFFINITY_HOST="$PARAM_VALUE"
        [ -z "$VM_HOST" ] && VM_HOST="$AFFINITY_HOST"
        if [ -n "$VM_HOST" ] && [ "$VM_HOST" == "$AFFINITY_HOST" ]; then
            (( ASSOC )) && VM_ASSOC=( ${VM_ASSOC[*]} "affinity" )
        fi
    fi
    # check for VDIs on local SR
    local VBD_UUIDS VBD_UUID
    vm_vbd_uuids "$VM_UUID"
    for VBD_UUID in ${VBD_UUIDS[@]}; do
        get_param vbd vdi-uuid "$VBD_UUID" || continue
        local VDI_UUID="$PARAM_VALUE"
        get_param vdi sr-uuid "$VDI_UUID" || continue
        local SR_UUID="$PARAM_VALUE"
        get_param sr host "$SR_UUID" || continue
        local SR_HOST="$PARAM_VALUE"
        if [ "$SR_HOST" != "<shared>" ]; then
            if [ -z "$VM_HOST" ]; then
                VM_HOST="$SR_HOST"
            fi
            if [ -n "$VM_HOST" ] && [ "$VM_HOST" == "$SR_HOST" ]; then
                (( ASSOC )) && VM_ASSOC=( ${VM_ASSOC[*]} "SR" )
                break
            fi
        fi
    done

    if [ -n "$VM_HOST" ]; then
        (( ASSOC )) && VM_HOST="$VM_HOST (${VM_ASSOC[*]})"
        return 0
    else
        return 1
    fi
}

# set values of params for UUID; interpret input args as list of two-tuples
function set_params() {
    if [ $# -lt 4 ] || [ $(( $# % 2 )) -ne 0 ]; then
        return 2
    fi
    local OBJECT="$1" UUID="$2"
    shift 2
    local CMD="xe $OBJECT-param-set uuid=$UUID"
    local PARAM_NAME PARAM_VALUE
    while [ -n "$1" ]; do
        PARAM_NAME="$1"
        shift
        PARAM_VALUE="$1"
        shift
        CMD="$CMD $PARAM_NAME=\"$PARAM_VALUE\""
    done
    eval "$CMD"
    return $?
}

# set values of map param for UUID
# $1: object type
# $2: object UUID
# $3: name of map parameter
# $...: key/value pairs of map parameter
function set_map_keys() {
    if [ $# -lt 5 ] || [ $(( $# % 2 )) -ne 1 ]; then
        return 2
    fi
    local OBJECT="$1" UUID="$2" PARAM_NAME="$3"
    shift 3
    local MAP_KEY MAP_VALUE
    local CMD="xe $OBJECT-param-set uuid=$UUID"
    while [ -n "$1" ]; do
        MAP_KEY="$1"
        shift
        MAP_VALUE="$1"
        shift
        CMD="$CMD $PARAM_NAME:$MAP_KEY=$MAP_VALUE"
    done
    eval "$CMD"
    return $?
}

# remove keys from map param for UUID
# $1: object type
# $2: object UUID
# $3: name of map parameter
# $...: keys of map parameter
function remove_map_keys() {
    [ $# -lt 4 ] && return 2
    local OBJECT="$1" UUID="$2" PARAM_NAME="$3"
    shift 3
    local CMD="xe vm-param-remove uuid=$UUID param-name=$PARAM_NAME" MAP_KEY
    while [ -n "$1" ]; do
        MAP_KEY="$1"
        shift
        eval "$CMD param-key=$MAP_KEY" || return $?
    done
    return $?
}
# 
########################################################################
# 
# Functions for input validation
#

function valid_uuid() {
    [ -z "$1" ] && return 2
    echo "$1" | egrep -q '^[0-9a-fA-F]{8}-([0-9a-fA-F]{4}-){3}[0-9a-fA-F]{12}$'
}

function valid_integer() {
    [ -z "$1" ] && return 2
    echo "$1" | egrep -q '^[0-9]*$'
}

function valid_mac_address() {
    [ -z "$1" ] && return 2
    echo "$1" | egrep -q '([0-9a-fA-F]{2}:){5}[0-9a-fA-F]{2}'
}

########################################################################
#
# Other functions
#

function prompt() {
    echo -e "$1 ${2-[y/N]?}: \c"
    local RESPONSE="n"
    read RESPONSE
    if echo "$RESPONSE" | egrep -q ' *[Yy] *'; then
        return 0
    else
        return 3
    fi
}

# check for non-empty variables named by arguments
function have_required() {
    [ -z "$1" ] && return 2
    for VAR_NAME in $*; do
        [ -z "${!VAR_NAME}" ] && return 1
    done
    return 0
}

# set all arguments to empty string
function initialize() {
    for VAR_NAME in $*; do
        eval "${VAR_NAME}"=""
    done
    return 0
}
